From f428a8a35f2b642a7bcedc493d6171911b59ba00 Mon Sep 17 00:00:00 2001
From: "Dmitry V. Levin" <ldv@strace.io>
Date: Mon, 15 Dec 2025 08:00:00 +0000
Subject: [PATCH 5/8] xlat: update IORING_OP_* constants

* bundled/linux/include/uapi/linux/io_uring.h: Update to
headers_install'ed Linux kernel v6.19-rc1.
* src/xlat/uring_ops.in (IORING_OP_NOP128, IORING_OP_URING_CMD128): New
constants introduced by Linux kernel commit v6.19-rc1~169^2~48.
* tests/io_uring_register.c (main): Update expected output.
* NEWS: Mention this change.
---
 NEWS                                        |  1 +
 bundled/linux/include/uapi/linux/io_uring.h | 43 +++++++++++++++++++++
 src/xlat/uring_ops.in                       |  2 +
 tests/io_uring_register.c                   | 24 ++++++------
 4 files changed, 58 insertions(+), 12 deletions(-)

diff --git a/NEWS b/NEWS
index 916c288f6..4dbbf9c80 100644
--- a/NEWS
+++ b/NEWS
@@ -3,6 +3,7 @@ Noteworthy changes in release ?.?? (????-??-??)
 
 * Improvements
   * Updated decoding of struct mnt_id_req.
+  * Updated the list of IORING_OP_* constants.
 
 Noteworthy changes in release 6.18 (2025-12-07)
 ===============================================
diff --git a/bundled/linux/include/uapi/linux/io_uring.h b/bundled/linux/include/uapi/linux/io_uring.h
index b7c8dad26..b5b23c0d5 100644
--- a/bundled/linux/include/uapi/linux/io_uring.h
+++ b/bundled/linux/include/uapi/linux/io_uring.h
@@ -231,6 +231,12 @@ enum io_uring_sqe_flags_bit {
  */
 #define IORING_SETUP_CQE_MIXED		(1U << 18)
 
+/*
+ * Allow both 64b and 128b SQEs. If a 128b SQE is posted, it will have
+ * a 128b opcode.
+ */
+#define IORING_SETUP_SQE_MIXED		(1U << 19)
+
 enum io_uring_op {
 	IORING_OP_NOP,
 	IORING_OP_READV,
@@ -295,6 +301,8 @@ enum io_uring_op {
 	IORING_OP_READV_FIXED,
 	IORING_OP_WRITEV_FIXED,
 	IORING_OP_PIPE,
+	IORING_OP_NOP128,
+	IORING_OP_URING_CMD128,
 
 	/* this goes last, obviously */
 	IORING_OP_LAST,
@@ -689,6 +697,9 @@ enum io_uring_register_op {
 	/* query various aspects of io_uring, see linux/io_uring/query.h */
 	IORING_REGISTER_QUERY			= 35,
 
+	/* auxiliary zcrx configuration, see enum zcrx_ctrl_op */
+	IORING_REGISTER_ZCRX_CTRL		= 36,
+
 	/* this goes last */
 	IORING_REGISTER_LAST,
 
@@ -998,6 +1009,7 @@ enum io_uring_socket_op {
 	SOCKET_URING_OP_GETSOCKOPT,
 	SOCKET_URING_OP_SETSOCKOPT,
 	SOCKET_URING_OP_TX_TIMESTAMP,
+	SOCKET_URING_OP_GETSOCKNAME,
 };
 
 /*
@@ -1052,6 +1064,10 @@ struct io_uring_zcrx_area_reg {
 	__u64	__resv2[2];
 };
 
+enum zcrx_reg_flags {
+	ZCRX_REG_IMPORT	= 1,
+};
+
 /*
  * Argument for IORING_REGISTER_ZCRX_IFQ
  */
@@ -1070,6 +1086,33 @@ struct io_uring_zcrx_ifq_reg {
 	__u64	__resv[3];
 };
 
+enum zcrx_ctrl_op {
+	ZCRX_CTRL_FLUSH_RQ,
+	ZCRX_CTRL_EXPORT,
+
+	__ZCRX_CTRL_LAST,
+};
+
+struct zcrx_ctrl_flush_rq {
+	__u64		__resv[6];
+};
+
+struct zcrx_ctrl_export {
+	__u32		zcrx_fd;
+	__u32 		__resv1[11];
+};
+
+struct zcrx_ctrl {
+	__u32	zcrx_id;
+	__u32	op; /* see enum zcrx_ctrl_op */
+	__u64	__resv[2];
+
+	union {
+		struct zcrx_ctrl_export		zc_export;
+		struct zcrx_ctrl_flush_rq	zc_flush;
+	};
+};
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/xlat/uring_ops.in b/src/xlat/uring_ops.in
index 029ed7b4e..a18004fba 100644
--- a/src/xlat/uring_ops.in
+++ b/src/xlat/uring_ops.in
@@ -65,3 +65,5 @@ IORING_OP_EPOLL_WAIT
 IORING_OP_READV_FIXED
 IORING_OP_WRITEV_FIXED
 IORING_OP_PIPE
+IORING_OP_NOP128
+IORING_OP_URING_CMD128
diff --git a/tests/io_uring_register.c b/tests/io_uring_register.c
index bfce33bcd..2ff6ea2da 100644
--- a/tests/io_uring_register.c
+++ b/tests/io_uring_register.c
@@ -370,12 +370,12 @@ main(void)
 	probe->ops[0].flags = 0;
 	probe->ops[0].resv2 = 0xbeefface;
 
-	probe->ops[1].op = 62;
+	probe->ops[1].op = 64;
 	probe->ops[1].resv = 0;
 	probe->ops[1].flags = IO_URING_OP_SUPPORTED;
 	probe->ops[1].resv2 = 0xdeadc0de;
 
-	probe->ops[2].op = 63;
+	probe->ops[2].op = 65;
 	probe->ops[2].resv = 0xaf;
 	probe->ops[2].flags = 0xbeef;
 	probe->ops[2].resv2 = 0;
@@ -390,41 +390,41 @@ main(void)
 	       ", ops_len=%hhu, resv2=[0, %#x, 0], ops=["
 	       "{op=" XLAT_FMT_U ", resv=0xde, flags=0, resv2=0xbeefface}, "
 	       "{op=" XLAT_FMT_U ", flags=" XLAT_FMT ", resv2=0xdeadc0de}, "
-	       "{op=63" NRAW(" /* IORING_OP_??? */") ", resv=0xaf, flags="
+	       "{op=65" NRAW(" /* IORING_OP_??? */") ", resv=0xaf, flags="
 	       XLAT_FMT "}, {op=254" NRAW(" /* IORING_OP_??? */")
 	       ", flags=0xc0de" NRAW(" /* IO_URING_OP_??? */") "}]}"
 #if RETVAL_INJECTED
 	       " => {last_op=" XLAT_FMT_U ", ops_len=%hhu, resv2=[0, %#x, 0], "
 	       "ops=[{op=" XLAT_FMT_U ", resv=0xde, flags=0, resv2=0xbeefface}"
 	       ", {op=" XLAT_FMT_U ", flags=" XLAT_FMT ", resv2=0xdeadc0de}"
-	       ", {op=63" NRAW(" /* IORING_OP_??? */") ", resv=0xaf, flags="
+	       ", {op=65" NRAW(" /* IORING_OP_??? */") ", resv=0xaf, flags="
 	       XLAT_FMT "}, {op=254" NRAW(" /* IORING_OP_??? */")
 	       ", flags=0xc0de" NRAW(" /* IO_URING_OP_??? */") "}, ...]}"
 #endif
 	       ", 4) = %s\n",
 	       fd_null, path_null, XLAT_ARGS(IORING_REGISTER_PROBE),
 	       XLAT_ARGS(IORING_OP_EPOLL_CTL), probe->ops_len, probe->resv2[1],
-	       XLAT_ARGS(IORING_OP_NOP), XLAT_ARGS(IORING_OP_PIPE),
+	       XLAT_ARGS(IORING_OP_NOP), XLAT_ARGS(IORING_OP_URING_CMD128),
 	       XLAT_ARGS(IO_URING_OP_SUPPORTED),
 	       XLAT_ARGS(IO_URING_OP_SUPPORTED|0xbeee),
 #if RETVAL_INJECTED
 	       XLAT_ARGS(IORING_OP_EPOLL_CTL), probe->ops_len, probe->resv2[1],
-	       XLAT_ARGS(IORING_OP_NOP), XLAT_ARGS(IORING_OP_PIPE),
+	       XLAT_ARGS(IORING_OP_NOP), XLAT_ARGS(IORING_OP_URING_CMD128),
 	       XLAT_ARGS(IO_URING_OP_SUPPORTED),
 	       XLAT_ARGS(IO_URING_OP_SUPPORTED|0xbeee),
 #endif
 	       errstr);
 
-	probe->last_op = 63;
+	probe->last_op = 65;
 	probe->resv2[1] = 0;
 	fill_memory_ex(probe->ops, sizeof(probe->ops[0]) * (DEFAULT_STRLEN + 1),
-		    0x40, 0x80);
+		       65, 0x80);
 	sys_io_uring_register(fd_null, IORING_REGISTER_PROBE, probe,
 			      DEFAULT_STRLEN + 1);
 	printf("io_uring_register(%u<%s>, " XLAT_FMT,
 	       fd_null, path_null, XLAT_ARGS(IORING_REGISTER_PROBE));
 	for (size_t c = 0; c < 1 + RETVAL_INJECTED; c++) {
-		printf("%s{last_op=63" NRAW(" /* IORING_OP_??? */")
+		printf("%s{last_op=65" NRAW(" /* IORING_OP_??? */")
 		       ", ops_len=%hhu, ops=[",
 		       c ? " => " : ", ", probe->ops_len);
 		for (size_t i = 0; i < DEFAULT_STRLEN; i++) {
@@ -494,9 +494,9 @@ main(void)
 		{ ARG_STR(IORING_RESTRICTION_SQE_OP), true,
 		  "sqe_op=", ARG_STR(IORING_OP_NOP), true },
 		{ ARG_STR(IORING_RESTRICTION_SQE_OP), true,
-		  "sqe_op=", ARG_STR(IORING_OP_PIPE), true },
+		  "sqe_op=", ARG_STR(IORING_OP_URING_CMD128), true },
 		{ ARG_STR(IORING_RESTRICTION_SQE_OP), true,
-		  "sqe_op=", 63, " /* IORING_OP_??? */", false },
+		  "sqe_op=", 65, " /* IORING_OP_??? */", false },
 		{ ARG_STR(IORING_RESTRICTION_SQE_OP), true,
 		  "sqe_op=", 255, " /* IORING_OP_??? */", false },
 		{ ARG_STR(IORING_RESTRICTION_SQE_FLAGS_ALLOWED), true,
@@ -1247,7 +1247,7 @@ main(void)
 			       (intmax_t) sync_cancel_reg->timeout.tv_nsec);
 			if (j & 0x20)
 				printf(", opcode=" XLAT_FMT,
-				       XLAT_ARGS(IORING_OP_PIPE));
+				       XLAT_ARGS(IORING_OP_URING_CMD128));
 			else
 				printf(", opcode=%#x"
 				       NRAW(" /* IORING_OP_??? */"),
-- 
2.34.1

